# tests/e2e/test_full_workflow.py
"""
End-to-end test for the full autonomous freelance workflow:
1. Job discovery
2. Decision to bid
3. Bid submission
4. Client communication & agreement
5. Task execution (transcription/translation/copywriting)
6. Quality control
7. Delivery
8. Payment processing
9. Post-service follow-up

This test uses mocked platforms and services to simulate real-world behavior
without external dependencies.
"""

import asyncio
import json
import os
import tempfile
from pathlib import Path
from unittest.mock import AsyncMock, patch, MagicMock

import pytest

from core.config.unified_config_manager import UnifiedConfigManager
from core.dependency.service_locator import ServiceLocator
from core.automation.auto_freelancer_core import AutoFreelancerCore
from platforms.platform_factory import PlatformFactory
from services.ai_services.transcription_service import TranscriptionService
from services.ai_services.translation_service import TranslationService
from services.ai_services.copywriting_service import CopywritingService
from core.payment.enhanced_payment_processor import EnhancedPaymentProcessor
from core.communication.empathetic_communicator import EmpatheticCommunicator
from core.monitoring.intelligent_monitoring_system import IntelligentMonitoringSystem


@pytest.fixture
def temp_data_dir():
    """Create a temporary directory for test data isolation."""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield Path(tmpdir)


@pytest.fixture
def mock_config(temp_data_dir):
    """Provide a minimal valid config for E2E test."""
    config_data = {
        "platforms": {
            "enabled": ["test_platform"],
            "test_platform": {
                "api_key": "mock_key",
                "poll_interval_sec": 1,
                "bid_budget_limit": 100.0
            }
        },
        "ai": {
            "models": {
                "transcription": "whisper-medium",
                "translation": "nllb-200",
                "copywriting": "gpt2-medium"
            }
        },
        "payment": {
            "providers": ["mock_provider"],
            "auto_invoice": True,
            "tax_rate": 0.13
        },
        "data": {
            "root": str(temp_data_dir)
        },
        "logging": {
            "level": "INFO"
        }
    }
    config_path = temp_data_dir / "test_config.json"
    with open(config_path, "w") as f:
        json.dump(config_data, f)
    return UnifiedConfigManager(config_path=str(config_path))


@pytest.fixture
def mock_services(mock_config):
    """Register mocked services into ServiceLocator."""
    locator = ServiceLocator()

    # Mock AI services
    transcription_mock = AsyncMock(spec=TranscriptionService)
    transcription_mock.process.return_value = "Transcribed text from mock audio."
    locator.register("transcription_service", transcription_mock)

    translation_mock = AsyncMock(spec=TranslationService)
    translation_mock.process.return_value = "Translated text in target language."
    locator.register("translation_service", translation_mock)

    copywriting_mock = AsyncMock(spec=CopywritingService)
    copywriting_mock.generate.return_value = "High-quality marketing copy generated by AI."
    locator.register("copywriting_service", copywriting_mock)

    # Mock payment processor
    payment_mock = AsyncMock(spec=EnhancedPaymentProcessor)
    payment_mock.process_payment.return_value = {"status": "success", "tx_id": "mock_tx_123"}
    locator.register("payment_processor", payment_mock)

    # Mock communicator
    comm_mock = AsyncMock(spec=EmpatheticCommunicator)
    comm_mock.send_message.return_value = True
    comm_mock.negotiate_terms.return_value = {"agreed": True, "price": 85.0, "deadline_hours": 24}
    locator.register("communicator", comm_mock)

    # Mock monitoring
    monitor_mock = AsyncMock(spec=IntelligentMonitoringSystem)
    locator.register("monitoring", monitor_mock)

    return locator


@pytest.fixture
def mock_platform():
    """Mock a freelance platform client."""
    with patch("platforms.platform_factory.PlatformFactory.create") as mock_create:
        platform_mock = AsyncMock()
        platform_mock.name = "test_platform"
        platform_mock.fetch_jobs.return_value = [
            {
                "job_id": "job_001",
                "title": "Transcribe 10-min interview",
                "description": "Need accurate transcription of English audio.",
                "budget": 90.0,
                "category": "transcription",
                "client_id": "client_abc",
                "deadline_hours": 48
            }
        ]
        platform_mock.submit_bid.return_value = {"status": "submitted", "bid_id": "bid_001"}
        platform_mock.get_conversation.return_value = []
        platform_mock.deliver_work.return_value = {"status": "delivered"}
        mock_create.return_value = platform_mock
        yield platform_mock


@pytest.mark.asyncio
async def test_full_autonomous_workflow(
        mock_config,
        mock_services,
        mock_platform,
        temp_data_dir
):
    """
    Test the entire autonomous workflow from job discovery to post-service.
    Ensures no component fails and all steps are executed in correct order.
    """
    # Arrange
    freelancer = AutoFreelancerCore(config=mock_config, service_locator=mock_services)

    # Act
    await freelancer.start()

    # Simulate one cycle (in real system this runs continuously)
    await freelancer.run_cycle()

    # Wait briefly for async tasks to complete
    await asyncio.sleep(0.1)

    # Assert: Platform interactions
    mock_platform.fetch_jobs.assert_called_once()
    mock_platform.submit_bid.assert_called_once_with(
        job_id="job_001",
        proposal="AI-generated unique bid tailored to your transcription needs.",
        price=85.0
    )
    mock_platform.deliver_work.assert_called_once()

    # Assert: AI services used
    transcription_service = mock_services.get("transcription_service")
    transcription_service.process.assert_called_once()

    # Assert: Communication happened
    communicator = mock_services.get("communicator")
    assert communicator.send_message.call_count >= 2  # Initial + delivery
    communicator.negotiate_terms.assert_called_once()

    # Assert: Payment processed
    payment = mock_services.get("payment_processor")
    payment.process_payment.assert_called_once_with(
        job_id="job_001",
        amount=85.0,
        currency="USD",
        client_id="client_abc"
    )

    # Assert: Data saved correctly
    jobs_dir = temp_data_dir / "jobs" / "job_001"
    assert jobs_dir.exists()
    assert (jobs_dir / "job_details.json").exists()
    assert (jobs_dir / "deliverables" / "output.txt").exists()

    deliverable_path = jobs_dir / "deliverables" / "output.txt"
    with open(deliverable_path, "r") as f:
        content = f.read()
    assert "Transcribed text from mock audio." in content

    # Assert: Monitoring recorded metrics
    monitor = mock_services.get("monitoring")
    assert monitor.log_metric.call_count > 0

    # Cleanup
    await freelancer.stop()