# AI_FREELANCE_AUTOMATION/tools/deployment/env_setup.py
"""
Environment Setup Tool for AI Freelance Automation System

This module handles:
- Creation of .env file from .env.example
- Validation of required environment variables
- Secure generation of cryptographic keys (if missing)
- Integration with core configuration system
- Safe fallbacks and user guidance

Designed to be idempotent, safe, and compliant with security best practices.
"""

import os
import logging
import secrets
import string
from pathlib import Path
from typing import Dict, List, Optional

# Avoid circular imports â€” use relative paths only to stable utils if needed
# Core dependencies are intentionally NOT imported here to keep this tool lightweight

logger = logging.getLogger("EnvSetup")


class EnvironmentSetupTool:
    """
    Manages environment setup for the AI Freelance Automation system.
    Ensures all required secrets and configs are present before first run.
    """

    REQUIRED_VARS: List[str] = [
        "APP_SECRET_KEY",
        "ENCRYPTION_MASTER_KEY",
        "DATABASE_URL",
        "LOG_LEVEL",
        "PLATFORM_UPWORK_API_KEY",
        "PLATFORM_FREELANCERU_TOKEN",
        "PAYMENT_STRIPE_SECRET_KEY",
        "AI_OPENAI_API_KEY",
        "SECURITY_SALT"
    ]

    OPTIONAL_VARS: Dict[str, str] = {
        "REDIS_URL": "redis://localhost:6379/0",
        "POSTGRES_HOST": "localhost",
        "POSTGRES_PORT": "5432",
        "DEBUG_MODE": "false",
        "AUTO_BACKUP_ENABLED": "true",
        "MONITORING_ENDPOINT": "http://localhost:9090"
    }

    def __init__(self, project_root: Optional[Path] = None):
        self.project_root = project_root or Path(__file__).parent.parent.parent.parent
        self.env_path = self.project_root / ".env"
        self.env_example_path = self.project_root / ".env.example"

    def _generate_secure_key(self, length: int = 64) -> str:
        """Generate a cryptographically secure random string."""
        alphabet = string.ascii_letters + string.digits + "!@#$%^&*(-_=+)"
        return ''.join(secrets.choice(alphabet) for _ in range(length))

    def _read_env_example(self) -> Dict[str, str]:
        """Parse .env.example into a dictionary."""
        if not self.env_example_path.exists():
            raise FileNotFoundError(f"Missing .env.example at {self.env_example_path}")

        env_vars = {}
        with open(self.env_example_path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#") and "=" in line:
                    key, value = line.split("=", 1)
                    env_vars[key.strip()] = value.strip().strip('"').strip("'")
        return env_vars

    def _write_env_file(self, env_vars: Dict[str, str]) -> None:
        """Write environment variables to .env file."""
        with open(self.env_path, "w", encoding="utf-8") as f:
            f.write("# Auto-generated by env_setup.py â€” DO NOT COMMIT TO VERSION CONTROL\n")
            f.write("# This file contains sensitive credentials. Keep it private.\n\n")
            for key, value in sorted(env_vars.items()):
                f.write(f'{key}="{value}"\n')
        logger.info(f"âœ… Generated .env file at {self.env_path}")

    def _validate_existing_env(self) -> Dict[str, str]:
        """Load and validate existing .env file."""
        env_vars = {}
        if not self.env_path.exists():
            return env_vars

        with open(self.env_path, "r", encoding=" utf-8") as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#") and "=" in line:
                    key, value = line.split("=", 1)
                    key = key.strip()
                    value = value.strip().strip('"').strip("'")
                    env_vars[key] = value
        return env_vars

    def setup_environment(self, force_regenerate: bool = False) -> bool:
        """
        Main entry point: set up environment securely.

        Args:
            force_regenerate (bool): If True, overwrite existing .env

        Returns:
            bool: True if setup succeeded
        """
        logger.info("ðŸ”§ Starting environment setup...")

        # Load base template
        try:
            base_vars = self._read_env_example()
        except Exception as e:
            logger.error(f"âŒ Failed to read .env.example: {e}")
            return False

        # Load existing .env if exists
        existing_vars = self._validate_existing_env() if not force_regenerate else {}

        # Merge: existing > base > defaults
        final_vars = base_vars.copy()
        final_vars.update(self.OPTIONAL_VARS)
        final_vars.update(existing_vars)

        # Generate missing secrets
        secrets_needed = False
        for var in self.REQUIRED_VARS:
            if not final_vars.get(var):
                if var == "APP_SECRET_KEY":
                    final_vars[var] = self._generate_secure_key(64)
                elif var == "ENCRYPTION_MASTER_KEY":
                    final_vars[var] = self._generate_secure_key(32)  # 256-bit
                elif var == "SECURITY_SALT":
                    final_vars[var] = self._generate_secure_key(32)
                else:
                    # For API keys, leave placeholder but warn
                    final_vars[var] = "YOUR_" + var
                    logger.warning(f"âš ï¸  Placeholder set for {var}. Replace manually!")
                secrets_needed = True

        # Write only if new or forced
        if not self.env_path.exists() or force_regenerate or secrets_needed:
            self._write_env_file(final_vars)
        else:
            logger.info("âœ… .env already exists and is complete. No changes made.")

        # Final validation
        missing = [var for var in self.REQUIRED_VARS if not final_vars.get(var) or final_vars[var].startswith("YOUR_")]
        if missing:
            logger.warning(f"â— Missing critical values in .env: {missing}")
            logger.info("ðŸ‘‰ Please edit .env and replace all YOUR_* placeholders with real credentials.")
        else:
            logger.info("âœ… Environment setup completed successfully!")

        return len(missing) == 0

    @classmethod
    def run(cls) -> bool:
        """Convenience method to run setup from CLI or script."""
        logging.basicConfig(level=logging.INFO)
        tool = cls()
        return tool.setup_environment()


# CLI entry point (optional)
if __name__ == "__main__":
    success = EnvironmentSetupTool.run()
    exit(0 if success else 1)