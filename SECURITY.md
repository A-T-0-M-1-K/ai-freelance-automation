# Политика безопасности AI Freelance Automation

## Сообщение об уязвимости

**Пожалуйста, не сообщайте об уязвимостях безопасности через публичные GitHub Issues.**

Если вы обнаружили уязвимость безопасности, отправьте описание на **security@example.com**.

**Включите в сообщение следующую информацию:**
*   Тип уязвимости (например, инъекция, XSS, утечка данных).
*   Полный путь к файлам исходного кода, связанным с уязвимостью.
*   Расположение затронутого кода (ветка, тег или коммит).
*   Конфигурация, необходимая для воспроизведения.
*   Пошаговые инструкции для воспроизведения.
*   Proof-of-concept или эксплойт-код (если возможно).
*   Возможное воздействие уязвимости.

**Процесс раскрытия:**
Мы предпочитаем скоординированное раскрытие. Мы обязуемся:
1.  Подтвердить получение отчета в течение **48 часов**.
2.  Расследовать и подтвердить проблему в течение **7 дней**.
3.  Разработать и протестировать исправление в течение **30 дней** для критических уязвимостей.
4.  Публично раскрыть информацию об уязвимости после выпуска исправления.

**Благодарность:** Мы с радостью выражаем благодарность в файле `SECURITY.md` исследователям, которые ответственно сообщают об уязвимостях (если они этого хотят).

## Область действия и архитектура безопасности

Приложение `AI Freelance Automation` обрабатывает следующие категории конфиденциальных данных:

1.  **Учетные данные фриланс-платформ:** Логины, пароли, API-токены, сессионные cookies для автоматического взаимодействия с сайтами (Freelance.ru, Upwork и др.).
2.  **API-ключи сторонних сервисов:** Ключи OpenAI, DeepL, Google и других AI-провайдеров.
3.  **Конфиденциальные данные клиентов:** Тексты, аудио- и видеофайлы, полученные для выполнения задач (транскрибация, перевод).
4.  **Финансовая информация:** История ставок, суммы выплат, банковские реквизиты (если интегрированы).
5.  **Метаданные деятельности:** Статистика по заказам, переписка с заказчиками, аналитика.

**Ключевые компоненты, требующие защиты:**
*   **Файлы конфигурации:** `.env`, `config/automation.json`
*   **Локальная база данных:** `data/jobs.db` (SQLite)
*   **Кэш AI-моделей и результатов:** `ai/cache/`, `ai/models/`
*   **Директории с пользовательскими данными:** `data/projects/`, `data/transcriptions/`

## Руководство по безопасной настройке

### 1. Управление секретами и API-ключами

**Никогда не храните секреты в коде или публичных репозиториях.** Все конфиденциальные данные должны находиться в файле `.env`, который добавлен в `.gitignore`.

**Пример безопасного `.env` файла:**
\`\`\`env
# OpenAI API (для GPT и, возможно, Whisper)
OPENAI_API_KEY=sk-...your-real-key-here...

# Ключи фриланс-платформ (используйте App Passwords или OAuth, где возможно)
FREELANCE_RU_PASSWORD=app-specific-password-generated-on-platform
UPWORK_API_SECRET=your-upwork-secret

# Ключ шифрования для локальных данных (сгенерируйте свой)
APP_ENCRYPTION_KEY=$(openssl rand -hex 32)
\`\`\`

**Для production-развертывания** используйте менеджеры секретов (HashiCorp Vault, AWS Secrets Manager) или переменные окружения облачного провайдера. Файл `.env` должен использоваться только для разработки.

### 2. Шифрование данных

Приложение использует модуль `app/utils/crypto.py` для шифрования чувствительных данных перед сохранением в базу данных или файлы.

**Что шифруется:**
*   Пароли и токены доступа к платформам (в БД).
*   API-ключи сторонних сервисов (в БД).
*   Конфиденциальные поля в логах.

**Что НЕ шифруется (для производительности):**
*   Метаданные заказов (ID, статус, бюджет).
*   Кэшированные результаты AI-обработки (если они не содержат PII).
*   Файлы конфигурации приложения (но они содержат только ссылки на секреты).

**Рекомендуемые алгоритмы (реализованы в `CryptoManager`):**
*   **Симметричное шифрование:** AES-256-GCM (через `cryptography.fernet`).
*   **Хеширование паролей:** PBKDF2 с SHA-256 (для мастер-пароля приложения, если будет реализован).
*   **Генерация ключей:** `os.urandom` или `secrets.token_bytes`.

### 3. Безопасность базы данных и файлового хранилища

**Локальная SQLite БД:**
*   База данных `data/jobs.db` должна быть доступна только для владельца процесса приложения.
*   Регулярно создавайте зашифрованные резервные копии с помощью `scripts/backup.py`.
*   Используйте параметризованные запросы (через SQLAlchemy) для предотвращения SQL-инъекций.

\`\`\`python
# ПРАВИЛЬНО (использование ORM/параметров)
session.query(Job).filter(Job.budget >= min_budget).all()

# НЕПРАВИЛЬНО (конкатенация строк - УЯЗВИМОСТЬ)
query = f"SELECT * FROM jobs WHERE budget >= {user_input}"
\`\`\`

**Права доступа к файлам (Linux/Unix):**
\`\`\`bash
# Рекомендуемые права для директорий и файлов с данными
chmod 700 data/ ai/ config/  # Только владелец
chmod 600 data/jobs.db .env config/automation.json
chmod 644 logs/app.log       # Логи могут быть читаемы другими процессами
\`\`\`

### 4. Безопасность сетевых взаимодействий

**При взаимодействии с внешними API:**
*   Всегда используйте HTTPS (`verify_ssl=True` в aiohttp).
*   Настраивайте разумные таймауты для запросов.
*   Реализуйте механизм повторных попыток (retry) с экспоненциальной отсрочкой.
*   Используйте User-Agent, идентифицирующий ваше приложение.

**При парсинге веб-страниц (JobScraper):**
*   Соблюдайте `robots.txt` целевых сайтов.
*   Реализуйте задержки между запросами, чтобы не создавать нагрузку.
*   Кэшируйте результаты, чтобы минимизировать количество запросов.
*   Используйте ротацию User-Agent и прокси (при необходимости) ответственно.

### 5. Логирование и аудит

**Логировать СЛЕДУЕТ (в `logs/`):**
*   Факты успешной и неудачной аутентификации на платформах.
*   Изменения критических настроек.
*   Запуск и завершение автоматических задач (парсинг, отправка ставок).
*   Ошибки при работе с AI-моделями.
*   События, связанные с финансовыми операциями.

**Логировать НЕ СЛЕДУЕТ (НИКОГДА):**
*   Пароли, API-ключи, токены доступа.
*   Полное содержимое приватных сообщений с клиентами.
*   Конфиденциальные данные из обрабатываемых файлов.
*   Ключи шифрования.

**Пример безопасного логирования:**
\`\`\`python
# ПРАВИЛЬНО
logger.info("Успешная аутентификация на platform_X для пользователя %s", username)
logger.error("Ошибка отправки ставки для заказа %s: %s", job_id, error_message)

# НЕПРАВИЛЬНО
logger.info(f"Используем API ключ: {openai_api_key}") # УТЕЧКА СЕКРЕТА
\`\`\`

## Ответственные практики разработки

### Стандарты кода и проверки
*   **Статический анализ:** Используйте `bandit` (конфигурация в `bandit.yml`) для поиска типичных уязвимостей Python.
*   **Зависимости:** Регулярно обновляйте зависимости (`pip-audit`, `safety check`). Используйте `requirements*.txt` с зафиксированными версиями для production.
*   **Code Review:** Все изменения, затрагивающие безопасность (аутентификация, шифрование, парсинг), должны проходить mandatory code review.

### Типичные уязвимости и их предотвращение

1.  **Инъекция команд/путей (в `file_utils.py`, `job_scraper.py`):**
    \`\`\`python
    # УЯЗВИМЫЙ КОД
    os.system(f"whisper {user_provided_path}") # Если user_provided_path = 'audio.mp3; rm -rf /'

    # ЗАЩИЩЕННЫЙ КОД
    import shlex
    safe_path = shlex.quote(user_provided_path) # Экранирование
    # ИЛИ ЛУЧШЕ: использовать встроенные библиотеки (subprocess с args)
    subprocess.run(["whisper", user_provided_path], check=True)
    \`\`\`

2.  **Десериализация недоверенных данных (конфигурация, кэш):**
    *   Всегда проверяйте цифровую подпись или хеш загружаемых AI-моделей.
    *   При загрузке JSON-кэша используйте `json.load()` для базовых данных, но будьте осторожны с выполнением кода из него.

3.  **Небезопасное хранение сессий платформ:**
    *   Cookies и сессионные токены, полученные при парсинге, должны храниться зашифрованными.
    *   Реализуйте механизм автоматического обновления/перелогина при истечении срока действия сессии.

### Рекомендации по развертыванию

**Для Docker (`docker/`):**
*   Используйте официальные минимальные образы (например, `python:3.10-slim`).
*   Запускайте контейнер от непривилегированного пользователя (`USER 1000` в Dockerfile).
*   Монтируйте секреты через `docker secrets` или как read-only volumes.
*   Регулярно обновляйте базовые образы.

**Для самостоятельного хостинга:**
*   Изолируйте приложение в отдельном пользовательском пространстве.
*   Настройте брандмауэр, чтобы ограничить входящие соединения (они обычно не требуются для headless-приложения).
*   Рассмотрите возможность запуска в `systemd` или `supervisord` с правильно настроенными ограничениями (cgroups, namespaces).

## Мониторинг и реагирование на инциденты

1.  **Мониторинг:**
    *   Отслеживайте необычную активность в логах (частота запросов, ошибки аутентификации).
    *   Настройте алерты на появление в логах ключевых слов: `CRITICAL`, `ERROR`, `пароль`, `ключ`, `утечка`.
    *   Регулярно проверяйте целостность критических файлов (`.env`, `*.db`) с помощью хешей.

2.  **План реагирования:**
    *   **Обнаружение:** Немедленно изолируйте пораженную систему (остановите контейнер/процесс).
    *   **Анализ:** Определите вектор атаки и масштаб утечки данных по логам.
    *   **Сдерживание:** Отзовите все скомпрометированные API-ключи и пароли на всех платформах.
    *   **Устранение:** Примените патч для уязвимости, очистите систему.
    *   **Восстановление:** Разверните чистую версию приложения с новыми ключами из защищенной резервной копии.
    *   **Пост-мортем:** Проведите анализ, обновите политики и документацию.

## Контакты

*   **Ответственный за безопасность:** security@example.com
*   **PGP Key Fingerprint:** `AAAA BBBB CCCC DDDD EEEE  FFFF 0000 1111 2222 3333` (если используется)
*   **Аварийные контакты:** emergency-contact@example.com

---

*Эта политика безопасности является живым документом и будет обновляться по мере развития проекта. Последнее обновление: 2024-01-16*